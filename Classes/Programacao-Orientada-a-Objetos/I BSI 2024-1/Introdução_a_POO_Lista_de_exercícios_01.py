# -*- coding: utf-8 -*-
"""Parte I - Introdução à POO - Lista de Exercícios 01

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FUykgD7RBwgWJ3GBuOgkcOU7mFVxkSx4

**• Classe Pessoa:** Crie uma classe que modele uma pessoa:

a. Atributos: nome, idade, peso e altura

b. Métodos: envelhecer, engordar, emagrecer, crescer.

Obs: Por padrão, a cada ano que nossa pessoa envelhece, sendo a idade dela menor que 21 anos,
ela deve crescer 0,5 cm.
"""

class Pessoa():
  def __init__(self,N,I,P,H):
    self.nome = N
    self.idade = I
    self.peso = P
    self.altura = H

  def Envelhecer(self):
    if self.idade < 21:
      self.altura = self.altura + 0.05
    self.idade = self.idade + 1

  def Engordar(self):
    self.peso = self.peso + 1

  def Emagrecer(self):
    self.peso = self.peso - 1

  def Crescer(self):
    self.altura = self.altura + 0.05

pessoa1 = Pessoa("Otavio",12,60,1.2)

pessoa1.Envelhecer()
print(pessoa1.idade)
print(pessoa1.altura)

pessoa1.Engordar()
print(pessoa1.peso)

pessoa1.Emagrecer()
print(pessoa1.peso)

pessoa1.Crescer()
print(pessoa1.altura)

"""**• Classe Conta Corrente:** Crie uma classe para implementar uma conta corrente. A classe deve
possuir os seguintes atributos: número da conta, nome do correntista e saldo. Os métodos são os
seguintes: alterarNome, depósito e saque. No construtor, saldo é opcional, com valor default zero e os
demais atributos são obrigatórios.
"""

class conta():
  def __init__(self, Num_C, Nome, Saldo=0):
    self.numero_conta = Num_C
    self.nome = Nome
    self.saldo = Saldo

  def AlterarNome(self):
    self.nome = input("Nome novo ")
    print(f"{self.nome} é o novo nome")

  def DepositSaque(self):
    DS = input("Deposito ou Saque ").capitalize()
    if DS[0] == "D":
      self.saldo = self.saldo + int(input("Valor do deposito "))
    elif DS[0] == "S":
      self.saldo = self.saldo - int(input("Valor do saque "))
    print(f"Seu novo saldo é: {self.saldo}")

conta1 = conta(77,"Otavio",)

print(conta1.numero_conta)
print(conta1.nome)
print(conta1.saldo)

conta1.AlterarNome()

conta1.DepositSaque()

"""**• Classe TV:** Faça um programa que simule um televisor criando-o como um objeto. O usuário deve
ser capaz de informar o número do canal e aumentar ou diminuir o volume. Certifique-se de que o
número do canal e o nível do volume permanecem dentro de faixas válidas.
"""

class TV():
  def __init__(self,NumC=0,Vol=0):
    self.num_canal = NumC
    self.volume = Vol

  def AlterarVol(self):
    while True:
      try:
        self.volume = int(input("Volume "))
        if self.volume < 0 or self.volume > 100:
            raise ValueError
        break
      except ValueError:
          print("Volume invalido: Tente novamente (O Volume deve estar entre 0 e 100)")
          print("")
    print(f"Seu volume agora é {self.volume}")

  def AlterarCanal(self):
    while True:
      try:
        self.num_canal = int(input("Canal "))
        if self.num_canal < 0 or self.num_canal > 200:
            raise ValueError
        break
      except ValueError:
          print("Canal invalido: Tente novamente (O Canal deve estar entre 0 e 200)")
          print("")
    print(f"Seu canal agora é {self.num_canal}")
    print("")

tv1 = TV()

tv1.AlterarVol()
tv1.AlterarCanal()

"""**• Classe Bichinho Virtual:** Crie uma classe que modele um Tamagushi (Bichinho Eletrônico):

a. Atributos: Nome, Fome, Saúde e Idade

b. Métodos: Alterar Nome, Fome, Saúde e Idade; Retornar Nome, Fome, Saúde e Idade

Obs: Existe mais uma informação que devemos levar em consideração, o Humor do nosso tamagushi,
este humor é uma combinação entre os atributos Fome e Saúde, ou seja, um campo calculado, então
não devemos criar um atributo para armazenar esta informação por que ela pode ser calculada a
qualquer momento.
"""

class Tamagushi():
  def __init__(self,Nome,Fome=100,HP=100,Idade=0):
    self.name = Nome
    self.hunger = Fome
    self.health = HP
    self.age = Idade

  def AlterarNome(self):
    self.name = input("Novo Nome ")
  def AlterarFome(self):
    self.hunger = int(input("Quanto de fome "))
  def AlterarHP(self):
    self.health = int(input("Qual a saude "))
  def AlterarIdade(self):
    self.age = input("Quão velho ")

  def Humor(self):
    self.humorQ = (self.health + self.hunger)/2
    if self.humorQ >= 80:
      self.humor = "Excelente"
    elif self.humorQ < 80 and self.humorQ >= 60:
      self.humor = "Bom"
    elif self.humorQ < 60 and self.humorQ >= 40:
      self.humor = "Ok"
    elif self.humorQ < 40 and self.humorQ >= 20:
      self.humor = "Ruim"
    elif self.humorQ < 20 and self.humorQ >= 0:
      self.humor = "Péssimo"
    print(self.humor)

tama1 = Tamagushi("Bernadim")

tama1.Humor()
print("")

tama1.AlterarFome()
tama1.AlterarHP()
print("")

tama1.Humor()

"""**• Classe Macaco:** Desenvolva uma classe Macaco, que possua os atributos nome e bucho (estomago)
e pelo menos os métodos comer(), verBucho() e digerir(). Faça um programa ou teste interativamente,
criando pelo menos dois macacos, alimentando-os com pelo menos 3 alimentos diferentes e verificando o conteúdo do estomago a cada refeição. Experimente fazer com que um macaco coma o
outro. É possível criar um macaco canibal?
"""

class Macaco():
  def __init__(self,Nome,Bucho=""):
    self.hunger = []
    self.name = Nome
    if Bucho == "":
      self.hunger.append(Bucho)
    for i in range(len(Bucho)):
      self.hunger.append(Bucho[i])
      print(self.hunger)

    if self.hunger[0] == '':
      self.hunger.pop(0)

  def Comer(self):
    self.hunger.append(input("Oque? "))
    print(self.hunger)
  def VerBucho(self):
    print(self.hunger)
  def Digerir(self):
    self.hunger.clear()
    print(self.hunger)
  def Comir(self):
    self.hunger.append(macaco1)
    print(self.hunger)


macaco1 = Macaco("Carnivoro",["Vaca","Boi","Peixe"])
macaco2 = Macaco("Herbivoro",["Planta"])

macaco1.Comer()
macaco1.Digerir()
macaco2.Comir()

"""**• Classe Ponto e Retangulo:** Faça um programa completo utilizando funções e classes que:

a. Possua uma classe chamada Ponto, com os atributos x e y.

b. Possua uma classe chamada Retangulo, com os atributos largura e altura.

c. Possua uma função para imprimir os valores da classe Ponto

d. Possua uma função para encontrar o centro de um Retângulo.

e. Você deve criar alguns objetos da classe Retangulo.

f. Cada objeto deve ter um vértice de partida, por exemplo, o vértice inferior esquerdo do
retângulo, que deve ser um objeto da classe Ponto.

g. A função para encontrar o centro do retângulo deve retornar o valor para um objeto do tipo
ponto que indique os valores de x e y para o centro do objeto.

h. O valor do centro do objeto deve ser mostrado na tela

i. Crie um menu para alterar os valores do retângulo e imprimir o centro deste retângulo.
"""

class Ponto():
  def __init__(self,Ponto1,Ponto2):
    self.y = Ponto1
    self.x = Ponto2


  def ValP(self):
    print(f"Ponto Y: {self.y} / Ponto X: {self.x}")

class Retangulo():
  def __init__(self,Altura,Largura):
    self.width = Largura
    self.height = Altura

  def MeioR(self):
    print(f"O meio do retangulo fica na Largura: {self.width/2} e Altura: {self.height/2}")
    return self.height/2 , self.width/2

retangulo1 = Retangulo(5,2)

pontoEI = Ponto(2, 2)
pontoES = Ponto(pontoEI.y + retangulo1.height, pontoEI.x)
pontoDI = Ponto(pontoEI.y, pontoEI.x + retangulo1.width)
pontoDS = Ponto(pontoEI.y + retangulo1.height, pontoEI.x + retangulo1.width)
print(retangulo1.MeioR())
Centro1 = Ponto(pontoEI.y + retangulo1.MeioR()[0], pontoEI.x + retangulo1.MeioR()[1])

print(pontoDS.ValP())
Centro1.ValP()

"""**• Classe Bomba de Combustível:** Faça um programa completo utilizando classes e métodos que:

a. Possua uma classe chamada bombaCombustível, com no mínimo esses atributos:

i. tipoCombustivel.

ii. valorLitro

iii. quantidadeCombustivel

b. Possua no mínimo esses métodos:

i. abastecerPorValor( ) – método onde é informado o valor a ser abastecido e mostra a
quantidade de litros que foi colocada no veículo.

ii. abastecerPorLitro( ) – método onde é informado a quantidade em litros de
combustível e mostra o valor a ser pago pelo cliente.

iii. alterarValor( ) – altera o valor do litro do combustível.

iv. alterarCombustivel( ) – altera o tipo do combustível.

v. alterarQuantidadeCombustivel( ) – altera a quantidade de combustível restante na
bomba.

OBS: Sempre que acontecer um abastecimento é necessário atualizar a quantidade de
combustível total na bomba.
"""

from abc import abstractstaticmethod
class BombaCombustivel():
  def __init__(self,Tipo,Valor,Quantia):
    self.tipoCombustivel = Tipo
    self.valorLitro = int(Valor)
    self.quantiaComb = int(Quantia)

  def abastecerPorValor(self, AbastecidoV):
    self.AbasVal = AbastecidoV / self.valorLitro
    self.quantiaComb = self.quantiaComb - self.AbasVal
    return self.AbasVal
  def abastecerPorLitro(self, AbastecidoLitro):
    self.AbasLitr = AbastecidoLitro * self.valorLitro
    self.quantiaComb = self.quantiaComb - AbastecidoLitro
    return self.AbasLitr
  def alterarValor(self):
    self.valorLitro = int(input("Quanto custa? "))
  def alterarCombustivel(self):
    self.tipoCombustivel = input("Qual sera o tipo? ")
  def alterarQuantidadeCombustivel(self):
    self.quantiaComb = int(input("Quanto sobrou? "))
  def getQC(self):
    print(self.quantiaComb)

Bomba1 = BombaCombustivel("MAC", 5, 1000)

Bomba1.abastecerPorValor(20)

Bomba1.getQC()

Bomba1.abastecerPorLitro(20)

Bomba1.getQC()

"""**• Classe Carro:** Implemente uma classe chamada Carro com as seguintes propriedades:

a. Um veículo tem um certo consumo de combustível (medidos em km / litro) e uma certa
quantidade de combustível no tanque.

b. O consumo é especificado no construtor e o nível de combustível inicial é 0.

c. Forneça um método andar( ) que simule o ato de dirigir o veículo por uma certa distância,
reduzindo o nível de combustível no tanque de gasolina.

d. Forneça um método obterGasolina( ), que retorna o nível atual de combustível.

e. Forneça um método adicionarGasolina( ), para abastecer o tanque. Exemplo de uso:

meuFusca = Carro(15)             # 15 quilômetros por litro de combustível.

meuFusca.adicionarGasolina(20)   # abastece com 20 litros de combustível.

meuFusca.andar(100)              # anda 100 quilômetros.

meuFusca.obterGasolina()         # Imprime o combustível que resta no tanque.
"""

class Carro():
  def __init__(self, Consumo, Quantia=0):
    self._QComb = Quantia
    self._KPL = Consumo

  def andar(self, Distancia):
    self._QComb = self._QComb - (Distancia / self._KPL)
  def obterGasolina(self):
    print(self._QComb)
  def adicionarGasolina(self, Add):
    self._QComb = self._QComb + Add

meuFusca = Carro(15) # 15 quilômetros por litro de combustível.

meuFusca.obterGasolina() # Imprime o combustível que resta no tanque

meuFusca.adicionarGasolina(20) # abastece com 20 litros de combustível.

meuFusca.andar(100) # anda 100 quilômetros.

meuFusca.obterGasolina() # Imprime o combustível que resta no tanque

"""**• Classe Conta de Investimento:** Faça uma classe chamada contaInvestimento que seja semelhante à
classe contaBancaria, com a diferença de que se adicione um atributo taxaJuros. Forneça um
construtor que configure tanto o saldo inicial como a taxa de juros. Forneça um método adicioneJuros
(sem parâmetro explícito) que adicione juros à conta. Escreva um programa que construa uma
poupança com um saldo inicial de R$1000,00 e uma taxa de juros de 10%. Depois aplique o método
adicioneJuros() cinco vezes e imprime o saldo resultante.
"""

class contaInvestimento():
  def __init__(self, Num_C, Nome, TX, Saldo=0):
    self.numero_conta = Num_C
    self.nome = Nome
    self.saldo = Saldo
    self.taxaJuros = TX

  def AlterarNome(self,NNome):
    self.nome = NNome
    print(f"{self.nome} é o novo nome")
  def DepositSaque(self,DepSaq,Quant):
    DS = DepSaq.capitalize()
    if DS[0] == "D":
      self.saldo = self.saldo + Quant
    elif DS[0] == "S":
      self.saldo = self.saldo - Quant
    print(f"Seu novo saldo é: {self.saldo}")
  def AdicioneJuros(self):
    self.saldo = self.saldo + (self.saldo * self.taxaJuros)

conta1 = contaInvestimento(77,"Otavio",0.10,1000)

print(conta1.numero_conta)
print(conta1.nome)
print(conta1.saldo)

print(conta1.saldo)

for i in range(5):
  conta1.AdicioneJuros()

print(conta1.saldo)

"""**• Classe Funcionário:** Implemente a classe Funcionário. Um empregado tem um nome (um string) e
um salário(um double). Escreva um construtor com dois parâmetros (nome e salário) e métodos para
devolver nome e salário. Escreva um pequeno programa que teste sua classe.
"""

class Funcionario():
  def __init__(self,Nome, Salario):
    self.name = Nome
    self.wageM = float(Salario)

  def getSalario(self):
    print(f"{self.wageM}")
  def getNome(self):
    print(f"{self.name}")

func1 = Funcionario("Otavio", 1000)

func1.getNome()
func1.getSalario()

"""• Aprimore a classe do exercício anterior para adicionar o método aumentarSalario
(porcentualDeAumento) que aumente o salário do funcionário em uma certa porcentagem.

• Exemplo de uso:

harry = funcionário("Harry",25000)

harry.aumentarSalario(10)
"""

class Funcionario():
  def __init__(self,Nome, Salario):
    self.name = Nome
    self.wageM = float(Salario)

  def getSalario(self):
    print(f"{self.wageM}")
  def getNome(self):
    print(f"{self.name}")
  def aumentarSalario(self, Aumento):
    self.wageM = self.wageM + (self.wageM * (Aumento/100))

harry = Funcionario("Harry", 25000)

harry.getNome()
harry.getSalario()

harry.aumentarSalario(10)
harry.getSalario()

"""**• Classe Bichinho Virtual++:** Melhore o programa do bichinho virtual, permitindo que o usuário
especifique quanto de comida ele fornece ao bichinho e por quanto tempo ele brinca com o bichinho.
Faça com que estes valores afetem quão rapidamente os níveis de fome e tédio caem.
"""

class Tamagushi():
  def __init__(self,Nome,Fome=100,HP=100,Idade=0):
    self.name = Nome
    self.hunger = Fome
    self.health = HP
    self.age = Idade
    self.DecayH = 0
    self.humorQ = (self.health + self.hunger)/2

  def AlterarNome(self, Nome):
    self.name = Nome
  def AlterarFome(self, Fome):
    self.hunger = int(Fome)
  def AddFome(self, Fome):
    self.hunger = self.hunger + int(Fome)
  def AlterarHP(self, HP):
    self.health = int(HP)
  def AlterarIdade(self, Idade):
    self.age = int(Idade)
  def Brincar(self, Tempo):
    for i in range(Tempo):
      if i < 10:
        self.DecayH = self.DecayH + 0.1
        self.hunger = self.hunger - 1
  def PassarTempo(self, Tempo):
    PTempo = Tempo
    for i in range(Tempo):
      self.hunger = self.hunger - 1
      self.humorQ = self.humorQ - (1 - (1 * self.DecayH) )

  def Humor(self):
    if self.humorQ >= 80:
      self.humor = "Excelente"
    elif self.humorQ < 80 and self.humorQ >= 60:
      self.humor = "Bom"
    elif self.humorQ < 60 and self.humorQ >= 40:
      self.humor = "Ok"
    elif self.humorQ < 40 and self.humorQ >= 20:
      self.humor = "Ruim"
    elif self.humorQ < 20 and self.humorQ >= 0:
      self.humor = "Péssimo"
    return self.humor

  def Status(self, TemNadaAQ=""):
    print(f"Humor: {self.Humor()}")
    print(f"Fome: {self.hunger}")
    if TemNadaAQ != "":
      eita = input("? ")
      eita = eita.upper()
      if eita[0] == "D":
        print(f"Nome = {self.name}")
        print(f"Fome = {self.hunger}")
        print(f"Saude = {self.health}")
        print(f"Iadede = {self.age}")
        print(f"Decaimento de Humor = {self.DecayH}")
        print(f"Humor Quantificado = {self.humorQ}")

bernado = Tamagushi("Bernadim")

bernado.Brincar(5)
bernado.Status()
bernado.PassarTempo(3)
bernado.Status("sadkljosauydasyububysabyadusy")

"""**• Crie uma "porta escondida"** no programa do bichinho virtual que mostre os valores exatos dos
atributos do objeto. Consiga isto mostrando o objeto quando uma opção secreta, não listada no menu,
for informada na escolha do usuário. Dica: acrescente um método especial str() à classe Bichinho.

• Crie uma Fazenda de Bichinhos instanciando vários objetos bichinho e mantendo o controle deles
através de uma lista. Imite o funcionamento do programa básico, mas ao invés de exigir que o usuário
tome conta de um único bichinho, exija que ele tome conta da fazenda inteira. Cada opção do menu
deveria permitir que o usuário executasse uma ação para todos os bichinhos (alimentar todos os
bichinhos, brincar com todos os bichinhos, ou ouvir a todos os bichinhos). Para tornar o programa
mais interessante, dê para cada bichinho um nível inicial aleatório de fome e tédio.
"""