# -*- coding: utf-8 -*-
"""Atividade Prática 02  Design Patterns (Padrões de Projeto) - Observer

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1B8bowdqF7FySSDs6mumuSy3ayq9jabcz

**1. Observe o diagrama de classes abaixo, e implemente o que se pede.**

• O padrão Observer é utilizado para realizar as operações de divisões inteiras e resto de divisão

• Cada vez que os valores no sujeito são atualizados, as operações devem ser realizadas e seus
resultados atualizados apresentados

• É necessário colocar mais uma variável para receber valores no Sujeito Concreto (valor1, valor2)

• A assinatura do método update() deve ser desenvolvida de acordo com a necessidade da aplicação

• Acrescente mais um observador que efetue a multiplicação dos valores
"""

from abc import ABC, abstractmethod


class Observer(ABC):
    @abstractmethod
    def update(self):
        pass

class Subject(ABC):
  @abstractmethod
  def registerObserver(self):
    pass

  @abstractmethod
  def removeObserver(self):
    pass

  @abstractmethod
  def notifyObservers(self):
    pass

class ConcreteSubject(Subject):
  def __init__(self, valor1, valor2):
    self.valor1 = valor1
    self.valor2 = valor2
    self.observers = []

  def registerObserver(self, observer):
    self.observers.append(observer)

  def removeObserver(self, observer):
    self.observers = [i for i in self.observers if i != observer]

  def notifyObservers(self):
    for observer in self.observers:
      observer.update(self.valor1, self.valor2)

  def getValor(self):
    return self.valor1, self.valor2

  def setValor1(self, valor):
    self.valor1 = valor
    self.notifyObservers()

  def setValor2(self, valor):
    self.valor2 = valor
    self.notifyObservers()

class DivObserver(Observer):
  def __init__(self, subject):
    self.subject = subject

  def update(self):
    valor1, valor2 = self.subject.getValor()
    div = valor1 / valor2
    print(f"Divisão: {div}")

class RestObserver(Observer):
  def __init__(self, subject):
    self.subject = subject

  def update(self):
    valor1, valor2 = self.subject.getValor()
    rest = valor1 % valor2
    print(f"Resto: {rest}")

class MultObserver(Observer):
  def __init__(self, subject):
    self.subject = subject

  def update(self):
    valor1, valor2 = self.subject.getValor()
    mult = valor1 * valor2
    print(f"Multiplicação: {mult}")

valores1 = ConcreteSubject(4, 4)
valores2 = ConcreteSubject(10, 2)
divisao1 = DivObserver(valores1)
divisao2 = DivObserver(valores2)
resto1 = RestObserver(valores1)
resto2 = RestObserver(valores2)
multiplicacao1 = MultObserver(valores1)
divisao1.update()
divisao2.update()
resto1.update()
resto2.update()
multiplicacao1.update()
print('')

valores1.setValor1(10)
valores1.setValor2(2)

divisao1.update()

"""Suponha que temos um objeto de fonte de notícias, vamos chamá-lo de Reuters. Além disso, temos
diferentes objetos de canal de notícias de TV que recebem notícias da Reuters e as retransmitem para
sua audiência. Esses canais de notícias precisam saber se a Reuters tem notícias de última hora ou não.
Se houver, eles devem obter essas notícias da Reuters e apresentá-las ao público.

Uma maneira de
fazer isso é consultar periodicamente o estado do objeto. Por exemplo, um diretor de nosso canal de
notícias de TV pode ligar para a Reuters em um determinado período (por exemplo, a cada 10 minutos)
e perguntar se há alguma notícia. No entanto, obviamente, esse método não pode ser um método bom
e eficaz. Desta forma, perturbaremos constantemente a fonte, seremos informados de qualquer
novidade (mudança de estado) não imediatamente, mas posteriormente.

**O Padrão de Projeto Observer
nos fornece uma solução eficaz. Nele, objetos observadores (assinantes) (pode ser mais de um) se
inscrevem no objeto sujeito (observável) que desejam estar cientes das atualizações em seu estado.
Quando o objeto sujeito sofre uma atualização, ele notifica os objetos que o subscreveram. Em outras
palavras, canais de TV (observadores) como Fox News ou CNN tornam-se assinantes da agência de
notícias Reuters (observáveis). A Reuters informa automaticamente seus assinantes sobre todas as notícias de última hora. Desenvolva o código deste cenário baseado no diagrama de classes UML
genérico da figura abaixo.**

!Observer = Observer | !Observable = Subject (interface) | Observer = Assinates | Subject
"""

from abc import ABC, abstractmethod

class Observer(ABC):
  @abstractmethod
  def update(self):
    pass

  def get_email(self):
    return self.email

  def get_nome(self):
    return self.nome

class Subject(ABC):
  @abstractmethod
  def subscribe(self):
    pass

  @abstractmethod
  def unsubscribe(self):
    pass

  @abstractmethod
  def notify(self):
    pass

class Email:
    @staticmethod
    def enviar_email(observer: Observer, mensagem: str):
        print('---------------------------------------------------------------------------')
        print(f'Email enviado para {observer.get_nome()} - {observer.get_email()}')
        print(f'Mensagem: {mensagem}\n')

class News(Subject):
  def __init__(self):
    self.observers = []
    self.mensagens = []

  def subscribe(self, observer):
    self.observers.append(observer)

  def unsubscribe(self, observer):
    self.observers = [i for i in self.observers if i != observer]

  def notify(self):
    for observer in self.observers:
      observer.update(self.mensagens[-1])

  def add_message(self, message):
    self.mensagens.append(message)
    self.notify()

class Assinantes(Observer):
  def __init__(self, nome, email, subject):
    self.nome = nome
    self.email = email
    self.subject = subject
    self.subject.subscribe(self)

  def get_email(self):
    return self.email

  def get_nome(self):
    return self.nome

  def update(self, noticia):
    Email.enviar_email(self, noticia)

news = News()

assinante1 = Assinantes("Claudio", "CLRAI@GMAIL.COM", news)
assinante2 = Assinantes("Maria", "MARIA@GMAIL.COM", news)
assinante3 = Assinantes("Jose", "JOSE@GMAIL.COM", news)

news.add_message("Noticia 1")
news.add_message("Noticia 2")
news.add_message("Noticia 3")