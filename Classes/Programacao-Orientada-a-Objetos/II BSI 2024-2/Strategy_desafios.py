# -*- coding: utf-8 -*-
"""Atividade Prática 02  Design Patterns (Padrões de Projeto) – Strategy  Desafios

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VCI02Iy91h1d0tkT2mrnLatJ_CzZ9ynW

**1. Criar um sistema que utilize o padrão Strategy para simular diferentes estratégias de deslocamento
usando meios de transporte variados.
Descrição: Crie uma aplicação Python que simule diferentes formas de transporte (carro, bicicleta, a pé),
permitindo ao usuário alternar entre elas e calcular o tempo necessário para percorrer uma determinada
distância.
Passos:**

• Crie uma interface TravelStrategy com um método travel_time que aceite uma distância em quilômetros.

• Implemente três classes de estratégia: CarStrategy, BicycleStrategy e WalkStrategy. Cada classe deve retornar
o tempo estimado para percorrer a distância fornecida com base em uma velocidade fixa (por exemplo:
carro 60 km/h, bicicleta 15 km/h, a pé 5 km/h).

• Crie uma classe TravelContext que contenha o método set_strategy para definir o meio de transporte atual e
um método calculate_time para calcular o tempo de viagem.

• Desenvolva uma interface simples que permita ao usuário escolher o meio de transporte e inserir a
distância.
"""

from abc import ABC, abstractmethod

class TravelStrategy(ABC):
    @abstractmethod
    def travel_time(self, distanceKm):
        pass

class CarStrategy(TravelStrategy):
    def travel_time(self, distanceKm):
        return distanceKm / 60

class BicycleStrategy(TravelStrategy):
    def travel_time(self, distanceKm):
        return distanceKm / 15

class WalkStrategy(TravelStrategy):
    def travel_time(self, distanceKm):
        return distanceKm / 5

class TravelContext:
    def __init__(self):
        self.strategy = None

    def set_strategy(self, strat):
        self.strategy = strat

    def calculate_time(self, distanceKm):
        return self.strategy.travel_time(distanceKm)

Carro1 = TravelContext()
Carro1.set_strategy(CarStrategy())
print(f"Tempo necessario para chegar de Carro: {Carro1.calculate_time(100)} (Horas)")

Bicicleta1 = TravelContext()
Bicicleta1.set_strategy(BicycleStrategy())
print(f"Tempo necessario para chegar de Bicicleta: {Bicicleta1.calculate_time(100)} (Horas)")

Caminhada1 = TravelContext()
Caminhada1.set_strategy(WalkStrategy())
print(f"Tempo necessario para chegar á pé: {Caminhada1.calculate_time(100)} (Horas)")

"""**2. Usar o padrão Strategy para aplicar diferentes estratégias de desconto em um sistema de compras.
Descrição: Desenvolva uma aplicação Python que simule a aplicação de descontos variáveis (desconto por
fidelidade, desconto sazonal, desconto por volume de compra) em um valor total de compra. A estratégia de
desconto deve poder ser trocada dinamicamente.
Passos:**

• Crie uma interface DiscountStrategy com um método apply_discount que aceite um valor de compra e
retorne o valor com desconto aplicado.

• Implemente três classes de estratégia: LoyaltyDiscount, SeasonalDiscount e BulkPurchaseDiscount. Cada
uma deve calcular o desconto de uma forma diferente (por exemplo, 5% para fidelidade, 10% para
compras em promoção, 15% para grandes quantidades).

• Crie uma classe ShoppingCart que use a estratégia de desconto. Essa classe deve ter o método
set_discount_strategy para alterar a estratégia de desconto e o método get_final_price para calcular o
valor total após aplicar o desconto.

• Permita que o usuário insira o valor total da compra e escolha o tipo de desconto a ser aplicado.
"""

from abc import ABC, abstractmethod

class DiscountStrategy(ABC):
  @abstractmethod
  def apply_discount(self, price):
    pass

class LoyaltyDiscount(DiscountStrategy):
  def apply_discount(self, price):
    return price * 0.95

class SeasonalDiscount(DiscountStrategy):
  def apply_discount(self, price):
    return price * 0.90

class BulkPurchaseDiscount(DiscountStrategy):
  def apply_discount(self, price):
    return price * 0.85

class ShoppingCart:
  def __init__(self):
    self.discount = None

  def set_discount_strategy(self, discount_strategy):
    self.discount = discount_strategy

  def final_price(self, price):
    if self.discount:
      return self.discount.apply_discount(price)
    else:
      return price

DiscontoL = ShoppingCart()
DiscontoL.set_discount_strategy(LoyaltyDiscount())
print(f"Valor com desconto de fidelidade: {DiscontoL.final_price(100)} (R$)")

DiscontoS = ShoppingCart()
DiscontoS.set_discount_strategy(SeasonalDiscount())
print(f"Valor com desconto de temporada: {DiscontoS.final_price(100)} (R$)")

DiscontoB = ShoppingCart()
DiscontoB.set_discount_strategy(BulkPurchaseDiscount())
print(f"Valor com desconto de volume: {DiscontoB.final_price(100)} (R$)")

"""**3. Implemente uma calculadora de impostos que use o padrão Strategy para aplicar diferentes tipos de
impostos (por exemplo, imposto sobre renda, imposto sobre vendas, imposto sobre produtos).
Passos:**

• Crie uma interface ImpostoStrategy com o método calcular.

• Implemente três estratégias: ImpostoRenda, ImpostoVendas e ImpostoProduto, cada uma com sua fórmula
de cálculo.

• Crie uma classe CalculadoraDeImposto que receba diferentes estratégias e aplique o cálculo.

• Crie uma função principal para testar o cálculo dos impostos com diferentes valores.
"""

from abc import ABC, abstractmethod

class ImpostoStrategy(ABC):
  @abstractmethod
  def calcular_impostos(self, valor):
    pass

class ImpostoRenda(ImpostoStrategy):
  def calcular_impostos(self, valor):
    return valor * 0.25

class ImpostoVendas(ImpostoStrategy):
  def calcular_impostos(self, valor):
    return valor * 0.1

class ImpostoProduto(ImpostoStrategy):
  def calcular_impostos(self, valor):
    return valor * 0.0

class CalculadoraDeImposto:
  def __init__(self):
    self.imposto = None

  def set_imposto_strategy(self, imposto_strategy):
    self.imposto = imposto_strategy

  def calcular_impostos(self, valor):
    if self.imposto:
      return self.imposto.calcular_impostos(valor)
    else:
      return valor

ImpostoR = CalculadoraDeImposto()
ImpostoR.set_imposto_strategy(ImpostoRenda())
print(f"Valor do imposto de renda: {ImpostoR.calcular_impostos(100)} (R$)")

ImpostoV = CalculadoraDeImposto()
ImpostoV.set_imposto_strategy(ImpostoVendas())
print(f"Valor do imposto de vendas: {ImpostoV.calcular_impostos(100)} (R$)")

ImpostoP = CalculadoraDeImposto()
ImpostoP.set_imposto_strategy(ImpostoProduto())
print(f"Valor do imposto de produto: {ImpostoP.calcular_impostos(100)} (R$)")

"""**4. Implemente um jogo simples onde diferentes personagens podem atacar usando estratégias de
ataque variadas (por exemplo, ataque corpo a corpo, ataque à distância, ataque mágico).
Passos:**

• Crie uma interface EstrategiaDeAtaque com o método atacar().

• Implemente três estratégias: AtaqueCorpoACorpo, AtaqueDistancia, e AtaqueMagico.

• Crie uma classe Personagem que tenha um nome e uma estratégia de ataque, permitindo alterar a
estratégia dinamicamente.

• Crie uma função principal para criar personagens e simular diferentes ataques.
"""

from abc import ABC, abstractmethod

class EstrategiaDeAtaque(ABC):
  @abstractmethod
  def atacar(self):
    pass

class AtaqueCorpoACorpo(EstrategiaDeAtaque):
  def atacar(self):
    return "Ataque Corpo a Corpo"

class AtaqueDistancia(EstrategiaDeAtaque):
  def atacar(self):
    return "Ataque Distáncia"

class AtaqueMagico(EstrategiaDeAtaque):
  def atacar(self):
    return "Ataque Magico"

class Personagem:
  def __init__(self, nome):
    self.nome = nome
    self.estrategia = None

  def set_estrategia(self, acao):
    self.estrategia = acao

  def atacar(self):
    if self.estrategia:
      return self.estrategia.atacar()

Personagem1 = Personagem("PaulinQueimaPneu")
Personagem1.set_estrategia(AtaqueCorpoACorpo())
print(f"{Personagem1.nome} usou um {Personagem1.atacar()}")
Personagem1.set_estrategia(AtaqueDistancia())
print("")
print(f"{Personagem1.nome} usou um {Personagem1.atacar()}")
print("")
Personagem1.set_estrategia(AtaqueMagico())
print(f"{Personagem1.nome} usou um {Personagem1.atacar()}")