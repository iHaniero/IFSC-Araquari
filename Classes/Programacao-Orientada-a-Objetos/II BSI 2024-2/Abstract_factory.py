# -*- coding: utf-8 -*-
"""Design Patterns (Padrões de Projeto) – Abstract Factory

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AslqlaSKwEGC9uj4o76pJaJm5QL5MfSw

2. Desenvolva o código para o diagrama de classes na figura abaixo, usando o padrão de design “Abstract
Factory”.
"""

# Fábrica

class Corporation:
    def create_motor_vehicle(self):
        pass

    def create_electric_vehicle(self):
        pass


# Interface

class Motorcycle():
    pass

class ElectricCar():
    pass


# Fábricas concretas

class FutureVehicleCorporation(Corporation):
    def create_motor_vehicle(self):
        return FutureVehicleMotorcycle()

    def create_electric_vehicle(self):
        return FutureVehicleElectricCar()


class NextGenerationVehicleCorporation(Corporation):
    def create_motor_vehicle(self):
        return NextGenMotorcycle()

    def create_electric_vehicle(self):
        return NextGenElectricCar()


# Objetos

class FutureVehicleMotorcycle(Motorcycle):
    pass

class FutureVehicleElectricCar(ElectricCar):
    pass

class NextGenMotorcycle(Motorcycle):
    pass

class NextGenElectricCar(ElectricCar):
    pass


# Teste

if __name__ == "__main__":
    # Cria instâncias das corporações
    future_corp = FutureVehicleCorporation()
    next_gen_corp = NextGenerationVehicleCorporation()

    # Cria veículos usando as fábricas
    future_motorcycle = future_corp.create_motor_vehicle()
    future_electric_car = future_corp.create_electric_vehicle()

    next_gen_motorcycle = next_gen_corp.create_motor_vehicle()
    next_gen_electric_car = next_gen_corp.create_electric_vehicle()

"""1. Desenvolva o código para os diagramas de classes das figuras abaixo, usando o padrão de design
“Abstract Factory”.
"""

from abc import ABC, abstractmethod

# Fábrica Abstrata
class FurnitureFactory(ABC):
    @abstractmethod
    def create_cabinet(self):
        pass

    @abstractmethod
    def create_chair(self):
        pass

    @abstractmethod
    def create_dining_table(self):
        pass


# Fábricas Específicas
class ScandinavianFactory(FurnitureFactory):
    def create_cabinet(self):
        return ScandinavianCabinet()

    def create_chair(self):
        return ScandinavianChair()

    def create_dining_table(self):
        return ScandinavianDiningTable()


class ClassicFactory(FurnitureFactory):
    def create_cabinet(self):
        return ClassicCabinet()

    def create_chair(self):
        return ClassicChair()

    def create_dining_table(self):
        return ClassicDiningTable()


class ContemporaryFactory(FurnitureFactory):
    def create_cabinet(self):
        return ContemporaryCabinet()

    def create_chair(self):
        return ContemporaryChair()

    def create_dining_table(self):
        return ContemporaryDiningTable()


# Interfaces dos Produtos
class Cabinet(ABC):
    @abstractmethod
    def describe(self):
        pass


class Chair(ABC):
    @abstractmethod
    def describe(self):
        pass


class DiningTable(ABC):
    @abstractmethod
    def describe(self):
        pass


# Produtos Específicos
class ScandinavianCabinet(Cabinet):
    def describe(self):
        return "Scandinavian-style Cabinet"


class ScandinavianChair(Chair):
    def describe(self):
        return "Scandinavian-style Chair"


class ScandinavianDiningTable(DiningTable):
    def describe(self):
        return "Scandinavian-style Dining Table"


class ClassicCabinet(Cabinet):
    def describe(self):
        return "Classic-style Cabinet"


class ClassicChair(Chair):
    def describe(self):
        return "Classic-style Chair"


class ClassicDiningTable(DiningTable):
    def describe(self):
        return "Classic-style Dining Table"


class ContemporaryCabinet(Cabinet):
    def describe(self):
        return "Contemporary-style Cabinet"


class ContemporaryChair(Chair):
    def describe(self):
        return "Contemporary-style Chair"


class ContemporaryDiningTable(DiningTable):
    def describe(self):
        return "Contemporary-style Dining Table"


# Teste
if __name__ == "__main__":
    # Escolha de fábrica (pode ser baseado em configurações, input do usuário, etc.)
    factory = ScandinavianFactory()

    # Criação de produtos
    cabinet = factory.create_cabinet()
    chair = factory.create_chair()
    table = factory.create_dining_table()

    # Descrição dos produtos criados
    print(cabinet.describe())  # Output: Scandinavian-style Cabinet
    print(chair.describe())    # Output: Scandinavian-style Chair
    print(table.describe())    # Output: Scandinavian-style Dining Table

"""**1. O que é o padrão de projeto Abstract Factory e qual é o seu objetivo principal?**

R: Fornece uma interface para criar famílias de objetos relacionados ou dependentes sem especificar suas classes concretas.

Em outras palavras, é um padrão criacional de projeto que fornece uma interface para criar objetos em uma superclasse, mas permite que essas subclasses alterem o tipo de objetos que serão criados.

**2. Como o padrão Abstract Factory ajuda a promover o princípio de "programe para
uma interface, não para uma implementação"?**

R: Ela enfatisa constatemente o uso da interface para cada objeto e até mesmo as Fabricas

**3. Quais são os componentes principais do padrão Abstract Factory? Explique cada um.**

R: Isolamento de produto e cliente: isola os produtos de seus clientes, tornando a dependência do cliente de uma fábrica específica. Isso permite que estes clientes sejam independentes das classes concretas dos produtos que usam.

Coesão de produtos: aumenta a coesão de produtos, permitindo que eles sejam agrupados em famílias com base em suas relações ou dependências.

Reuso de código: permite o reuso de código, pois os clientes podem usar a mesma interface para criar produtos de diferentes famílias.

Extensibilidade: é extensível, pois permite a adição de novas famílias de produtos sem alterar o código do cliente.

Desacoplamento (Decoupling): ajuda a manter o código desacoplado das classes concretas dos objetos que está criando. Isso significa que o código do cliente que utiliza a fábrica não precisa saber detalhes sobre as classes específicas dos objetos que está criando.

Configuração Flexível: permite que você substitua uma fábrica concreta por outra sem afetar o código do cliente. Isso possibilita a troca de famílias de objetos de forma flexível e fácil.

Garantia de Consistência: garante que os objetos criados sejam compatíveis entre si e pertençam à mesma família. Isso ajuda a evitar problemas de incompatibilidade entre objetos que podem ocorrer quando os objetos são criados de maneira independente.

Múltiplas Implementações: Você pode ter várias implementações diferentes de fábricas abstratas para criar objetos de acordo com diferentes contextos ou configurações do aplicativo.

**4. No exemplo da pizzaria, como o padrão Abstract Factory contribui para garantir
consistência nos ingredientes utilizados?**

R: Ele colocou todos os ingredientes em uma familia em interfaces que conseguem garantir uma padronização e se desacoplar do produto real

**5. Explique a diferença entre os padrões Abstract Factory e Factory Method.**

R:
Factory Method

* Expõe um método ao cliente para criar os objetos
* Usa herança e subclasses para decidir qual objeto criar
* É usado para criar um produto

Abstract Factory

* Contém um ou mais métodos de fábrica (i.e. Factory Methods) para criar uma família de objetos relacionados
* Usa composição para delegar responsabilidade para criar objetos de outra classe
* Trata da criação de famílias de produtos relacionados

**6. Quais são as vantagens do uso do padrão Abstract Factory em projetos de software?**

R: Em um jogo que oferece suporte a múltiplas plataformas, você pode usar uma Abstract Factory para criar recursos gráficos, como modelos 3D, texturas e efeitos sonoros, que são específicos para cada plataforma de destino.

**7. Como o padrão Abstract Factory pode ser aplicado para criar famílias de objetos
relacionados ou dependentes sem especificar suas classes concretas?**

R: O padrão Abstract Factory permite criar famílias de objetos relacionados ou dependentes sem especificar suas classes concretas, delegando a criação para subclasses específicas. Isso é feito por meio de interfaces ou classes abstratas que definem os métodos de criação de objetos. O cliente usa a fábrica abstrata sem precisar conhecer as implementações concretas.

**8. Descreva uma situação do mundo real, diferente da pizzaria, onde o padrão Abstract
Factory seria uma boa escolha.***

R: Um exemplo do mundo real seria o desenvolvimento de um sistema de processamento de pagamentos. Suponha que o sistema precise suportar múltiplos provedores de pagamento, como PayPal, Stripe e PagSeguro. Cada provedor exige diferentes configurações e comportamentos para criar objetos como validador de pagamento, conector API e gerenciador de transações. Tambem há o xemplo do boleto passado nas atividades.

**9. Quais são os possíveis desafios ou desvantagens do uso do padrão Abstract Factory
em um sistema?**

R:

* Complexidade Adicional: A introdução de interfaces e fábricas concretas pode tornar o código mais complicado e difícil de seguir, especialmente para projetos simples.
* Aumento no Número de Classes: O padrão geralmente exige a criação de várias classes (interfaces, fábricas concretas e classes de produtos), o que pode dificultar a manutenção.
* Rigidez: Adicionar novas famílias de produtos pode ser difícil, pois exige alterações na interface ou na classe abstrata, impactando todas as fábricas concretas existentes.
* Sobrecarga de Implementação: Pode ser um exagero para sistemas pequenos ou com requisitos simples, onde o uso de classes concretas seria mais eficiente.
* Dependência Indireta: Embora o cliente não dependa diretamente das classes concretas, ele ainda depende da fábrica, criando uma forma de acoplamento indireto.

**10. Como o padrão Abstract Factory pode ser combinado com outros padrões de projeto,
como o Singleton ou o Builder, para resolver problemas complexos de design?**

R:
* O Singleton pode ser usado para garantir que uma única instância de uma fábrica concreta seja usada em todo o sistema.
* O Builder pode ser usado dentro do Abstract Factory para criar objetos mais complexos, que requerem várias etapas de construção.
* O Abstract Factory pode delegar a criação de objetos individuais a métodos de fábrica específicos.
"""